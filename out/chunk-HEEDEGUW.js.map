{
  "version": 3,
  "sources": ["../../node_modules/chess.js/src/chess.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport const WHITE = 'w'\nexport const BLACK = 'b'\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport type Color = 'w' | 'b'\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\n\n// prettier-ignore\nexport type Square =\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\n\nexport const DEFAULT_POSITION =\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nexport type Piece = {\n  color: Color\n  type: PieceSymbol\n}\n\ntype InternalMove = {\n  color: Color\n  from: number\n  to: number\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: number\n}\n\ninterface History {\n  move: InternalMove\n  kings: Record<Color, number>\n  turn: Color\n  castling: Record<Color, number>\n  epSquare: number\n  halfMoves: number\n  moveNumber: number\n}\n\nexport type Move = {\n  color: Color\n  from: Square\n  to: Square\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: string\n  san: string\n  lan: string\n  before: string\n  after: string\n}\n\nconst EMPTY = -1\n\nconst FLAGS: Record<string, string> = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q',\n}\n\n// prettier-ignore\nexport const SQUARES: Square[] = [\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n]\n\nconst BITS: Record<string, number> = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64,\n}\n\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88: Record<Square, number> = {\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n}\n\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n];\n\n// prettier-ignore\nconst RAYS = [\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n];\n\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\n\nconst RANK_1 = 7\nconst RANK_2 = 6\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1\nconst RANK_8 = 0\n\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE,\n}\n\nconst ROOKS = {\n  w: [\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n  ],\n  b: [\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n  ],\n}\n\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\n\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\n\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square: number): number {\n  return square >> 4\n}\n\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square: number): number {\n  return square & 0xf\n}\n\nfunction isDigit(c: string): boolean {\n  return '0123456789'.indexOf(c) !== -1\n}\n\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square: number): Square {\n  const f = file(square)\n  const r = rank(square)\n  return ('abcdefgh'.substring(f, f + 1) +\n    '87654321'.substring(r, r + 1)) as Square\n}\n\nfunction swapColor(color: Color): Color {\n  return color === WHITE ? BLACK : WHITE\n}\n\nexport function validateFen(fen: string) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  // 9th criterion: is en-passant square legal?\n  if (\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\n    (tokens[3][1] == '6' && tokens[1] == 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n  }\n\n  // 10th criterion: does chess position contain exact two kings?\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  // 11th criterion: are any pawns on the first or eighth rows?\n  if (\n    Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')\n  ) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: some pawns are on the edge rows',\n    }\n  }\n\n  return { ok: true }\n}\n\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]) {\n  const from = move.from\n  const to = move.to\n  const piece = move.piece\n\n  let ambiguities = 0\n  let sameRank = 0\n  let sameFile = 0\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from\n    const ambigTo = moves[i].to\n    const ambigPiece = moves[i].piece\n\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from)\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1)\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0)\n    }\n  }\n\n  return ''\n}\n\nfunction addMove(\n  moves: InternalMove[],\n  color: Color,\n  from: number,\n  to: number,\n  piece: PieceSymbol,\n  captured: PieceSymbol | undefined = undefined,\n  flags: number = BITS.NORMAL,\n) {\n  const r = rank(to)\n\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i]\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION,\n      })\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags,\n    })\n  }\n}\n\nfunction inferPieceType(san: string) {\n  let pieceType = san.charAt(0)\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n    if (matches) {\n      return undefined\n    }\n    return PAWN\n  }\n  pieceType = pieceType.toLowerCase()\n  if (pieceType === 'o') {\n    return KING\n  }\n  return pieceType as PieceSymbol\n}\n\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move: string) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\nfunction trimFen(fen: string): string {\n  /*\n   * remove last two fields in FEN string as they're not needed when checking\n   * for repetition\n   */\n  return fen.split(' ').slice(0, 4).join(' ')\n}\n\nexport class Chess {\n  private _board = new Array<Piece>(128)\n  private _turn: Color = WHITE\n  private _header: Record<string, string> = {}\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\n  private _epSquare = -1\n  private _halfMoves = 0\n  private _moveNumber = 0\n  private _history: History[] = []\n  private _comments: Record<string, string> = {}\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\n  private _positionCounts: Record<string, number> = {}\n\n  constructor(fen = DEFAULT_POSITION) {\n    this.load(fen)\n  }\n\n  clear({ preserveHeaders = false } = {}) {\n    this._board = new Array<Piece>(128)\n    this._kings = { w: EMPTY, b: EMPTY }\n    this._turn = WHITE\n    this._castling = { w: 0, b: 0 }\n    this._epSquare = EMPTY\n    this._halfMoves = 0\n    this._moveNumber = 1\n    this._history = []\n    this._comments = {}\n    this._header = preserveHeaders ? this._header : {}\n\n    /*\n     * Delete the SetUp and FEN headers (if preserved), the board is empty and\n     * these headers don't make sense in this state. They'll get added later\n     * via .load() or .put()\n     */\n    delete this._header['SetUp']\n    delete this._header['FEN']\n\n    /*\n     * Instantiate a proxy that keeps track of position occurrence counts for the purpose\n     * of repetition checking. The getter and setter methods automatically handle trimming\n     * irrelevent information from the fen, initialising new positions, and removing old\n     * positions from the record if their counts are reduced to 0.\n     */\n    this._positionCounts = new Proxy({} as Record<string, number>, {\n      get: (target, position: string) =>\n        position === 'length'\n          ? Object.keys(target).length // length for unit testing\n          : target?.[trimFen(position)] || 0,\n      set: (target, position: string, count: number) => {\n        const trimmedFen = trimFen(position)\n        if (count === 0) delete target[trimmedFen]\n        else target[trimmedFen] = count\n        return true\n      },\n    })\n  }\n\n  removeHeader(key: string) {\n    if (key in this._header) {\n      delete this._header[key]\n    }\n  }\n\n  load(fen: string, { skipValidation = false, preserveHeaders = false } = {}) {\n    let tokens = fen.split(/\\s+/)\n\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1']\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\n    }\n\n    tokens = fen.split(/\\s+/)\n\n    if (!skipValidation) {\n      const { ok, error } = validateFen(fen)\n      if (!ok) {\n        throw new Error(error)\n      }\n    }\n\n    const position = tokens[0]\n    let square = 0\n\n    this.clear({ preserveHeaders })\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK\n        this._put(\n          { type: piece.toLowerCase() as PieceSymbol, color },\n          algebraic(square),\n        )\n        square++\n      }\n    }\n\n    this._turn = tokens[1] as Color\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\n    this._halfMoves = parseInt(tokens[4], 10)\n    this._moveNumber = parseInt(tokens[5], 10)\n\n    this._updateSetup(fen)\n    this._positionCounts[fen]++\n  }\n\n  fen() {\n    let empty = 0\n    let fen = ''\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        const { color, type: piece } = this._board[i]\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      } else {\n        empty++\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    let castling = ''\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K'\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q'\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k'\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q'\n    }\n\n    // do we have an empty castling flag?\n    castling = castling || '-'\n\n    let epSquare = '-'\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\n\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue\n        }\n\n        const color = this._turn\n\n        // is there a pawn that can capture the epSquare?\n        if (\n          this._board[square]?.color === color &&\n          this._board[square]?.type === PAWN\n        ) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: PAWN,\n            captured: PAWN,\n            flags: BITS.EP_CAPTURE,\n          })\n          const isLegal = !this._isKingAttacked(color)\n          this._undoMove()\n\n          // if ep is legal, break and set the ep square in the FEN output\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare)\n            break\n          }\n        }\n      }\n    }\n\n    return [\n      fen,\n      this._turn,\n      castling,\n      epSquare,\n      this._halfMoves,\n      this._moveNumber,\n    ].join(' ')\n  }\n\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  private _updateSetup(fen: string) {\n    if (this._history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1'\n      this._header['FEN'] = fen\n    } else {\n      delete this._header['SetUp']\n      delete this._header['FEN']\n    }\n  }\n\n  reset() {\n    this.load(DEFAULT_POSITION)\n  }\n\n  get(square: Square) {\n    return this._board[Ox88[square]] || false\n  }\n\n  put({ type, color }: { type: PieceSymbol; color: Color }, square: Square) {\n    if (this._put({ type, color }, square)) {\n      this._updateCastlingRights()\n      this._updateEnPassantSquare()\n      this._updateSetup(this.fen())\n      return true\n    }\n    return false\n  }\n\n  private _put(\n    { type, color }: { type: PieceSymbol; color: Color },\n    square: Square,\n  ) {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false\n    }\n\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false\n    }\n\n    const sq = Ox88[square]\n\n    // don't let the user place more than one king\n    if (\n      type == KING &&\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\n    ) {\n      return false\n    }\n\n    const currentPieceOnSquare = this._board[sq]\n\n    // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n    if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n      this._kings[currentPieceOnSquare.color] = EMPTY\n    }\n\n    this._board[sq] = { type: type as PieceSymbol, color: color as Color }\n\n    if (type === KING) {\n      this._kings[color] = sq\n    }\n\n    return true\n  }\n\n  remove(square: Square) {\n    const piece = this.get(square)\n    delete this._board[Ox88[square]]\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return piece\n  }\n\n  private _updateCastlingRights() {\n    const whiteKingInPlace =\n      this._board[Ox88.e1]?.type === KING &&\n      this._board[Ox88.e1]?.color === WHITE\n    const blackKingInPlace =\n      this._board[Ox88.e8]?.type === KING &&\n      this._board[Ox88.e8]?.color === BLACK\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.a1]?.type !== ROOK ||\n      this._board[Ox88.a1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.h1]?.type !== ROOK ||\n      this._board[Ox88.h1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.a8]?.type !== ROOK ||\n      this._board[Ox88.a8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.h8]?.type !== ROOK ||\n      this._board[Ox88.h8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE\n    }\n  }\n\n  private _updateEnPassantSquare() {\n    if (this._epSquare === EMPTY) {\n      return\n    }\n\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n    const attackers = [currentSquare + 1, currentSquare - 1]\n\n    if (\n      this._board[startSquare] !== null ||\n      this._board[this._epSquare] !== null ||\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\n      this._board[currentSquare]?.type !== PAWN\n    ) {\n      this._epSquare = EMPTY\n      return\n    }\n\n    const canCapture = (square: number) =>\n      !(square & 0x88) &&\n      this._board[square]?.color === this._turn &&\n      this._board[square]?.type === PAWN\n\n    if (!attackers.some(canCapture)) {\n      this._epSquare = EMPTY\n    }\n  }\n\n  private _attacked(color: Color, square: number) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue\n      }\n\n      const piece = this._board[i]\n      const difference = i - square\n\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue\n      }\n\n      const index = difference + 119\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        const offset = RAYS[index]\n        let j = i + offset\n\n        let blocked = false\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  private _isKingAttacked(color: Color) {\n    const square = this._kings[color]\n    return square === -1 ? false : this._attacked(swapColor(color), square)\n  }\n\n  isAttacked(square: Square, attackedBy: Color) {\n    return this._attacked(attackedBy, Ox88[square])\n  }\n\n  isCheck() {\n    return this._isKingAttacked(this._turn)\n  }\n\n  inCheck() {\n    return this.isCheck()\n  }\n\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0\n  }\n\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0\n  }\n\n  isInsufficientMaterial() {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces: Record<PieceSymbol, number> = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0,\n    }\n    const bishops = []\n    let numPieces = 0\n    let squareColor = 0\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      const piece = this._board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor)\n        }\n        numPieces++\n      }\n    }\n\n    // k vs. k\n    if (numPieces === 2) {\n      return true\n    } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0\n      const len = bishops.length\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  private _getRepetitionCount() {\n    return this._positionCounts[this.fen()]\n  }\n\n  isThreefoldRepetition(): boolean {\n    return this._getRepetitionCount() >= 3\n  }\n\n  isDraw() {\n    return (\n      this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n      this.isStalemate() ||\n      this.isInsufficientMaterial() ||\n      this.isThreefoldRepetition()\n    )\n  }\n\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw()\n  }\n\n  moves(): string[]\n  moves({ square }: { square: Square }): string[]\n  moves({ piece }: { piece: PieceSymbol }): string[]\n\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\n\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\n  moves({\n    verbose,\n    square,\n  }: {\n    verbose?: boolean\n    square?: Square\n  }): string[] | Move[]\n\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\n  moves({\n    verbose,\n    piece,\n  }: {\n    verbose?: boolean\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: true\n    square?: Square\n    piece?: PieceSymbol\n  }): Move[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: false\n    square?: Square\n    piece?: PieceSymbol\n  }): string[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose?: boolean\n    square?: Square\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\n\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined,\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\n    const moves = this._moves({ square, piece })\n\n    if (verbose) {\n      return moves.map((move) => this._makePretty(move))\n    } else {\n      return moves.map((move) => this._moveToSan(move, moves))\n    }\n  }\n\n  private _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined,\n  }: {\n    legal?: boolean\n    piece?: PieceSymbol\n    square?: Square\n  } = {}) {\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\n    const forPiece = piece?.toLowerCase()\n\n    const moves: InternalMove[] = []\n    const us = this._turn\n    const them = swapColor(us)\n\n    let firstSquare = Ox88.a8\n    let lastSquare = Ox88.h1\n    let singleSquare = false\n\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return []\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare]\n        singleSquare = true\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7\n        continue\n      }\n\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue\n      }\n      const { type } = this._board[from]\n\n      let to: number\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue\n\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0]\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN)\n\n          // double square\n          to = from + PAWN_OFFSETS[us][1]\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\n          }\n        }\n\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j]\n          if (to & 0x88) continue\n\n          if (this._board[to]?.color === them) {\n            addMove(\n              moves,\n              us,\n              from,\n              to,\n              PAWN,\n              this._board[to].type,\n              BITS.CAPTURE,\n            )\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j]\n          to = from\n\n          while (true) {\n            to += offset\n            if (to & 0x88) break\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type)\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break\n\n              addMove(\n                moves,\n                us,\n                from,\n                to,\n                type,\n                this._board[to].type,\n                BITS.CAPTURE,\n              )\n              break\n            }\n\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break\n          }\n        }\n      }\n    }\n\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom + 2\n\n          if (\n            !this._board[castlingFrom + 1] &&\n            !this._board[castlingTo] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom + 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.KSIDE_CASTLE,\n            )\n          }\n        }\n\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom - 2\n\n          if (\n            !this._board[castlingFrom - 1] &&\n            !this._board[castlingFrom - 2] &&\n            !this._board[castlingFrom - 3] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom - 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.QSIDE_CASTLE,\n            )\n          }\n        }\n      }\n    }\n\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves\n    }\n\n    // filter out illegal moves\n    const legalMoves = []\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i])\n      }\n      this._undoMove()\n    }\n\n    return legalMoves\n  }\n\n  move(\n    move: string | { from: string; to: string; promotion?: string },\n    { strict = false }: { strict?: boolean } = {},\n  ) {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n\n    let moveObj = null\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict)\n    } else if (typeof move === 'object') {\n      const moves = this._moves()\n\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (\n          move.from === algebraic(moves[i].from) &&\n          move.to === algebraic(moves[i].to) &&\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\n        ) {\n          moveObj = moves[i]\n          break\n        }\n      }\n    }\n\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`)\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\n      }\n    }\n\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = this._makePretty(moveObj)\n\n    this._makeMove(moveObj)\n    this._positionCounts[prettyMove.after]++\n    return prettyMove\n  }\n\n  private _push(move: InternalMove) {\n    this._history.push({\n      move,\n      kings: { b: this._kings.b, w: this._kings.w },\n      turn: this._turn,\n      castling: { b: this._castling.b, w: this._castling.w },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber,\n    })\n  }\n\n  private _makeMove(move: InternalMove) {\n    const us = this._turn\n    const them = swapColor(us)\n    this._push(move)\n\n    this._board[move.to] = this._board[move.from]\n    delete this._board[move.from]\n\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        delete this._board[move.to - 16]\n      } else {\n        delete this._board[move.to + 16]\n      }\n    }\n\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._board[move.to] = { type: move.promotion, color: us }\n    }\n\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to\n\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1\n        const castlingFrom = move.to + 1\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1\n        const castlingFrom = move.to - 2\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      }\n\n      // turn off castling\n      this._castling[us] = 0\n    }\n\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          this._castling[us] & ROOKS[us][i].flag\n        ) {\n          this._castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          this._castling[them] & ROOKS[them][i].flag\n        ) {\n          this._castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === BLACK) {\n        this._epSquare = move.to - 16\n      } else {\n        this._epSquare = move.to + 16\n      }\n    } else {\n      this._epSquare = EMPTY\n    }\n\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0\n    } else {\n      this._halfMoves++\n    }\n\n    if (us === BLACK) {\n      this._moveNumber++\n    }\n\n    this._turn = them\n  }\n\n  undo() {\n    const move = this._undoMove()\n    if (move) {\n      const prettyMove = this._makePretty(move)\n      this._positionCounts[prettyMove.after]--\n      return prettyMove\n    }\n    return null\n  }\n\n  private _undoMove() {\n    const old = this._history.pop()\n    if (old === undefined) {\n      return null\n    }\n\n    const move = old.move\n\n    this._kings = old.kings\n    this._turn = old.turn\n    this._castling = old.castling\n    this._epSquare = old.epSquare\n    this._halfMoves = old.halfMoves\n    this._moveNumber = old.moveNumber\n\n    const us = this._turn\n    const them = swapColor(us)\n\n    this._board[move.from] = this._board[move.to]\n    this._board[move.from].type = move.piece // to undo any promotions\n    delete this._board[move.to]\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index: number\n        if (us === BLACK) {\n          index = move.to - 16\n        } else {\n          index = move.to + 16\n        }\n        this._board[index] = { type: PAWN, color: them }\n      } else {\n        // regular capture\n        this._board[move.to] = { type: move.captured, color: them }\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo: number, castlingFrom: number\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1\n        castlingFrom = move.to - 1\n      } else {\n        castlingTo = move.to - 2\n        castlingFrom = move.to + 1\n      }\n\n      this._board[castlingTo] = this._board[castlingFrom]\n      delete this._board[castlingFrom]\n    }\n\n    return move\n  }\n\n  pgn({\n    newline = '\\n',\n    maxWidth = 0,\n  }: { newline?: string; maxWidth?: number } = {}) {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n\n    const result: string[] = []\n    let headerExists = false\n\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline)\n      headerExists = true\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline)\n    }\n\n    const appendComment = (moveString: string) => {\n      const comment = this._comments[this.fen()]\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : ''\n        moveString = `${moveString}${delimiter}{${comment}}`\n      }\n      return moveString\n    }\n\n    // pop all of history onto reversed_history\n    const reversedHistory = []\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    const moves = []\n    let moveString = ''\n\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''))\n    }\n\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString)\n      const move = reversedHistory.pop()\n\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break\n      }\n\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString)\n        }\n        moveString = this._moveNumber + '.'\n      }\n\n      moveString =\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\n      this._makeMove(move)\n    }\n\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString))\n    }\n\n    // is there a result?\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result)\n    }\n\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ')\n    }\n\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop()\n        return true\n      }\n      return false\n    }\n\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width: number, move: string) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--\n          }\n          result.push(newline)\n          width = 0\n        }\n        result.push(token)\n        width += token.length\n        result.push(' ')\n        width++\n      }\n      if (strip()) {\n        width--\n      }\n      return width\n    }\n\n    // wrap the PGN output at max_width\n    let currentWidth = 0\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i])\n          continue\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop()\n        }\n\n        result.push(newline)\n        currentWidth = 0\n      } else if (i !== 0) {\n        result.push(' ')\n        currentWidth++\n      }\n      result.push(moves[i])\n      currentWidth += moves[i].length\n    }\n\n    return result.join('')\n  }\n\n  header(...args: string[]) {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1]\n      }\n    }\n    return this._header\n  }\n\n  loadPgn(\n    pgn: string,\n    {\n      strict = false,\n      newlineChar = '\\r?\\n',\n    }: { strict?: boolean; newlineChar?: string } = {},\n  ) {\n    function mask(str: string): string {\n      return str.replace(/\\\\/g, '\\\\')\n    }\n\n    function parsePgnHeader(header: string): { [key: string]: string } {\n      const headerObj: Record<string, string> = {}\n      const headers = header.split(new RegExp(mask(newlineChar)))\n      let key = ''\n      let value = ''\n\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\n        key = headers[i].replace(regex, '$1')\n        value = headers[i].replace(regex, '$2')\n        if (key.trim().length > 0) {\n          headerObj[key] = value\n        }\n      }\n\n      return headerObj\n    }\n\n    // strip whitespace from head/tail of PGN block\n    pgn = pgn.trim()\n\n    /*\n     * RegExp to split header. Takes advantage of the fact that header and movetext\n     * will always have a blank line between them (ie, two newline_char's). Handles\n     * case where movetext is empty by matching newlineChar until end of string is\n     * matched - effectively trimming from the end extra newlineChar.\n     *\n     * With default newline_char, will equal:\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n     */\n    const headerRegex = new RegExp(\n      '^(\\\\[((?:' +\n        mask(newlineChar) +\n        ')|.)*\\\\])' +\n        '((?:\\\\s*' +\n        mask(newlineChar) +\n        '){2}|(?:\\\\s*' +\n        mask(newlineChar) +\n        ')*$)',\n    )\n\n    // If no header given, begin with moves.\n    const headerRegexResults = headerRegex.exec(pgn)\n    const headerString = headerRegexResults\n      ? headerRegexResults.length >= 2\n        ? headerRegexResults[1]\n        : ''\n      : ''\n\n    // Put the board in the starting position\n    this.reset()\n\n    // parse PGN header\n    const headers = parsePgnHeader(headerString)\n    let fen = ''\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key]\n      }\n\n      this.header(key, headers[key])\n    }\n\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, { preserveHeaders: true })\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error(\n            'Invalid PGN: FEN tag must be supplied with SetUp tag',\n          )\n        }\n        // don't clear the headers when loading\n        this.load(headers['FEN'], { preserveHeaders: true })\n      }\n    }\n\n    /*\n     * NB: the regexes below that delete move numbers, recursive annotations,\n     * and numeric annotation glyphs may also match text in comments. To\n     * prevent this, we transform comments by hex-encoding them in place and\n     * decoding them again after the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded, we use\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n     * for modern users\n     */\n\n    function toHex(s: string): string {\n      return Array.from(s)\n        .map(function (c) {\n          /*\n           * encodeURI doesn't transform most ASCII characters, so we handle\n           * these ourselves\n           */\n          return c.charCodeAt(0) < 128\n            ? c.charCodeAt(0).toString(16)\n            : encodeURIComponent(c).replace(/%/g, '').toLowerCase()\n        })\n        .join('')\n    }\n\n    function fromHex(s: string): string {\n      return s.length == 0\n        ? ''\n        : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'))\n    }\n\n    const encodeComment = function (s: string) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ')\n      return `{${toHex(s.slice(1, s.length - 1))}}`\n    }\n\n    const decodeComment = function (s: string) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1))\n      }\n    }\n\n    // delete header to get the moves\n    let ms = pgn\n      .replace(headerString, '')\n      .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'),\n        function (_match, bracket, semicolon) {\n          return bracket !== undefined\n            ? encodeComment(bracket)\n            : ' ' + encodeComment(`{${semicolon.slice(1)}}`)\n        },\n      )\n      .replace(new RegExp(mask(newlineChar), 'g'), ' ')\n\n    // delete recursive annotation variations\n    const ravRegex = /(\\([^()]+\\))+?/g\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '')\n    }\n\n    // delete move numbers\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n    // delete ... indicating black to move\n    ms = ms.replace(/\\.\\.\\./g, '')\n\n    /* delete numeric annotation glyphs */\n    ms = ms.replace(/\\$\\d+/g, '')\n\n    // trim and get array of moves\n    let moves = ms.trim().split(new RegExp(/\\s+/))\n\n    // delete empty entries\n    moves = moves.filter((move) => move !== '')\n\n    let result = ''\n\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove])\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment\n        continue\n      }\n\n      const move = this._moveFromSan(moves[halfMove], strict)\n\n      // invalid move\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove]\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`)\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = ''\n        this._makeMove(move)\n        this._positionCounts[this.fen()]++\n      }\n    }\n\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result)\n    }\n  }\n\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n  private _moveToSan(move: InternalMove, moves: InternalMove[]) {\n    let output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    this._makeMove(move)\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    this._undoMove()\n\n    return output\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move)\n\n    let pieceType = inferPieceType(cleanMove)\n    let moves = this._moves({ legal: true, piece: pieceType })\n\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i]\n      }\n    }\n\n    // the strict parser failed\n    if (strict) {\n      return null\n    }\n\n    let piece = undefined\n    let matches = undefined\n    let from = undefined\n    let to = undefined\n    let promotion = undefined\n\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n\n    let overlyDisambiguated = false\n\n    matches = cleanMove.match(\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/,\n      //     piece         from              to       promotion\n    )\n\n    if (matches) {\n      piece = matches[1]\n      from = matches[2] as Square\n      to = matches[3] as Square\n      promotion = matches[4]\n\n      if (from.length == 1) {\n        overlyDisambiguated = true\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n\n      matches = cleanMove.match(\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/,\n      )\n\n      if (matches) {\n        piece = matches[1]\n        from = matches[2] as Square\n        to = matches[3] as Square\n        promotion = matches[4]\n\n        if (from.length == 1) {\n          overlyDisambiguated = true\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove)\n    moves = this._moves({\n      legal: true,\n      piece: piece ? (piece as PieceSymbol) : pieceType,\n    })\n\n    if (!to) {\n      return null\n    }\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n        // if there is no from square, it could be just 'x' missing from a capture\n        if (\n          cleanMove ===\n          strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')\n        ) {\n          return moves[i]\n        }\n        // hand-compare move properties with the results from our permissive regex\n      } else if (\n        (!piece || piece.toLowerCase() == moves[i].piece) &&\n        Ox88[from] == moves[i].from &&\n        Ox88[to] == moves[i].to &&\n        (!promotion || promotion.toLowerCase() == moves[i].promotion)\n      ) {\n        return moves[i]\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n\n        const square = algebraic(moves[i].from)\n        if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[to] == moves[i].to &&\n          (from == square[0] || from == square[1]) &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  ascii() {\n    let s = '   +------------------------+\\n'\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type\n        const color = this._board[i].color\n        const symbol =\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      } else {\n        s += ' . '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h'\n\n    return s\n  }\n\n  perft(depth: number) {\n    const moves = this._moves({ legal: false })\n    let nodes = 0\n    const color = this._turn\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1)\n        } else {\n          nodes++\n        }\n      }\n      this._undoMove()\n    }\n\n    return nodes\n  }\n\n  // pretty = external move object\n  private _makePretty(uglyMove: InternalMove): Move {\n    const { color, piece, from, to, flags, captured, promotion } = uglyMove\n\n    let prettyFlags = ''\n\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag]\n      }\n    }\n\n    const fromAlgebraic = algebraic(from)\n    const toAlgebraic = algebraic(to)\n\n    const move: Move = {\n      color,\n      piece,\n      from: fromAlgebraic,\n      to: toAlgebraic,\n      san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n      flags: prettyFlags,\n      lan: fromAlgebraic + toAlgebraic,\n      before: this.fen(),\n      after: '',\n    }\n\n    // generate the FEN for the 'after' key\n    this._makeMove(uglyMove)\n    move.after = this.fen()\n    this._undoMove()\n\n    if (captured) {\n      move.captured = captured\n    }\n    if (promotion) {\n      move.promotion = promotion\n      move.lan += promotion\n    }\n\n    return move\n  }\n\n  turn() {\n    return this._turn\n  }\n\n  board() {\n    const output = []\n    let row = []\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null)\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color,\n        })\n      }\n      if ((i + 1) & 0x88) {\n        output.push(row)\n        row = []\n        i += 8\n      }\n    }\n\n    return output\n  }\n\n  squareColor(square: Square) {\n    if (square in Ox88) {\n      const sq = Ox88[square]\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\n    }\n\n    return null\n  }\n\n  history(): string[]\n  history({ verbose }: { verbose: true }): Move[]\n  history({ verbose }: { verbose: false }): string[]\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\n  history({ verbose = false }: { verbose?: boolean } = {}) {\n    const reversedHistory = []\n    const moveHistory = []\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n\n      if (verbose) {\n        moveHistory.push(this._makePretty(move))\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()))\n      }\n      this._makeMove(move)\n    }\n\n    return moveHistory\n  }\n\n  private _pruneComments() {\n    const reversedHistory = []\n    const currentComments: Record<string, string> = {}\n\n    const copyComment = (fen: string) => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen]\n      }\n    }\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    copyComment(this.fen())\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n      this._makeMove(move)\n      copyComment(this.fen())\n    }\n    this._comments = currentComments\n  }\n\n  getComment() {\n    return this._comments[this.fen()]\n  }\n\n  setComment(comment: string) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\n  }\n\n  deleteComment() {\n    const comment = this._comments[this.fen()]\n    delete this._comments[this.fen()]\n    return comment\n  }\n\n  getComments() {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen: string) => {\n      return { fen: fen, comment: this._comments[fen] }\n    })\n  }\n\n  deleteComments() {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen) => {\n      const comment = this._comments[fen]\n      delete this._comments[fen]\n      return { fen: fen, comment: comment }\n    })\n  }\n\n  setCastlingRights(\n    color: Color,\n    rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>,\n  ) {\n    for (const side of [KING, QUEEN] as const) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side]\n        } else {\n          this._castling[color] &= ~SIDES[side]\n        }\n      }\n    }\n\n    this._updateCastlingRights()\n    const result = this.getCastlingRights(color)\n\n    return (\n      (rights[KING] === undefined || rights[KING] === result[KING]) &&\n      (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\n    )\n  }\n\n  getCastlingRights(color: Color) {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n    }\n  }\n\n  moveNumber() {\n    return this._moveNumber\n  }\n}\n"],
  "mappings": "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",
  "names": ["WHITE", "BLACK", "PAWN", "KNIGHT", "BISHOP", "ROOK", "QUEEN", "KING", "DEFAULT_POSITION", "FLAGS", "BITS", "Ox88", "PAWN_OFFSETS", "PIECE_OFFSETS", "ATTACKS", "RAYS", "PIECE_MASKS", "SYMBOLS", "PROMOTIONS", "KNIGHT", "BISHOP", "ROOK", "QUEEN", "RANK_1", "RANK_2", "RANK_7", "RANK_8", "SIDES", "KING", "ROOKS", "SECOND_RANK", "TERMINATION_MARKERS", "rank", "square", "file", "isDigit", "c", "algebraic", "f", "r", "swapColor", "color", "WHITE", "BLACK", "validateFen", "fen", "tokens", "moveNumber", "halfMoves", "rows", "i", "sumFields", "previousWasNumber", "k", "kings", "regex", "char", "getDisambiguator", "move", "moves", "from", "to", "piece", "ambiguities", "sameRank", "sameFile", "len", "ambigFrom", "ambigTo", "ambigPiece", "addMove", "captured", "flags", "PAWN", "promotion", "inferPieceType", "san", "pieceType", "strippedSan", "trimFen", "Chess", "DEFAULT_POSITION", "preserveHeaders", "target", "position", "count", "trimmedFen", "key", "skipValidation", "adjustments", "ok", "error", "empty", "castling", "epSquare", "bigPawnSquare", "squares", "isLegal", "type", "sq", "currentPieceOnSquare", "whiteKingInPlace", "blackKingInPlace", "startSquare", "currentSquare", "attackers", "canCapture", "difference", "index", "offset", "j", "blocked", "attackedBy", "pieces", "bishops", "numPieces", "squareColor", "sum", "verbose", "legal", "forSquare", "forPiece", "us", "them", "firstSquare", "lastSquare", "singleSquare", "castlingFrom", "castlingTo", "legalMoves", "strict", "moveObj", "prettyMove", "old", "newline", "maxWidth", "result", "headerExists", "appendComment", "moveString", "comment", "delimiter", "reversedHistory", "prefix", "strip", "wrapComment", "width", "token", "currentWidth", "args", "pgn", "newlineChar", "mask", "str", "parsePgnHeader", "header", "headerObj", "headers", "value", "headerRegexResults", "headerString", "toHex", "s", "fromHex", "encodeComment", "decodeComment", "ms", "_match", "bracket", "semicolon", "ravRegex", "halfMove", "output", "disambiguator", "cleanMove", "matches", "overlyDisambiguated", "symbol", "depth", "nodes", "uglyMove", "prettyFlags", "flag", "FLAGS", "fromAlgebraic", "toAlgebraic", "row", "moveHistory", "currentComments", "copyComment", "rights", "side"]
}
